<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!-- Work around issues in MSBuild versions prior to 16.0. -->
  <PropertyGroup>
    <MSBuildAllProjects Condition=" '$(MSBuildVersion)' == '' Or '$(MSBuildVersion)' &lt; '16.0' ">
      $(MSBuildAllProjects);$(MSBuildThisFileFullPath)
    </MSBuildAllProjects>
  </PropertyGroup>
  
  <!-- We want access to the full path of packages as determined by msbuild to filter and reorder various package references. -->
  <ItemDefinitionGroup>
    <PackageReference GeneratePathProperty="true" IsQscReference ="false" />
  </ItemDefinitionGroup>
  

  <!-- Packages containing rewrite steps that are executed during compilation. -->
  <ItemGroup>
    <!-- for backwards compatibility we still generate C# independent on whether the project is targeted for execution on the simulation framework or not -->
    <PackageReference 
      Include="Microsoft.Quantum.CsharpGeneration" Version="0.10.1911.1607" IsImplicitlyDefined="true" 
      IsQscReference ="true" ExecutionTarget="Any" Priority="0" />
  </ItemGroup>

  <!-- Packages and libraries included for all execution targets. -->
  <ItemGroup>
    <!-- TODO: Core & Intrinsics package -->
    <PackageReference Include="Microsoft.Quantum.Standard" Version="0.10.1911.1607" IsImplicitlyDefined="true" />
  </ItemGroup>


  <!-- Includes packages and project references depending on the defined project properties. -->
  <Target Name="PropertyDependentReferences" DependsOnTargets="QsharpPropertyResolution" BeforeTargets="ResolveAssemblyReferences">
    <ItemGroup>
      <!-- Packages included for specific execution targets. -->
      <PackageReference Condition="'$(ResolvedQsharpExecutionTarget)' == 'SimulatorBackend'" Include="Microsoft.Quantum.Simulators" Version="0.10.1911.1607" IsImplicitlyDefined="true" />
    </ItemGroup>
  </Target>   


  <!-- Resolution of verified configurable properties. -->
  <Target Name="QsharpPropertyResolution">
    <!-- resolving the OutputType to either QsharpExe or QsharpLibrary -->
    <PropertyGroup>
      <ResolvedQsharpOutputType Condition="'$(OutputType)' == 'Library'">QsharpLibrary</ResolvedQsharpOutputType>
      <ResolvedQsharpOutputType Condition="'$(OutputType)' == 'Exe'">QsharpExe</ResolvedQsharpOutputType>
      <ResolvedQsharpOutputType Condition="'$(ResolvedQsharpOutputType)' != 'QsharpLibrary' And '$(ResolvedQsharpOutputType)' != 'QsharpExe'"></ResolvedQsharpOutputType>
      <ValidOutputTypes>Possible values are 'Exe', or 'Library'.</ValidOutputTypes>
    </PropertyGroup>
    <!-- resolving the ExecutionTarget to either SimulatorBackend or QuantumProcessorBackend -->
    <PropertyGroup>
      <!-- TODO: RENAME QuantumProcessorArchitecture and remove simulator distinction -->
      <ResolvedQsharpExecutionTarget Condition="'$(ExecutionTarget)' == 'QuantumProcessor'">QuantumProcessorBackend</ResolvedQsharpExecutionTarget> <!-- TODO: replace that -->
      <ResolvedQsharpExecutionTarget Condition="'$(ExecutionTarget)' == 'QuantumSimulator' Or '$(ExecutionTarget)' == 'ToffoliSimulator' Or '$(ExecutionTarget)' == 'TraceSimulator'">SimulatorBackend</ResolvedQsharpExecutionTarget>
      <ResolvedQsharpExecutionTarget Condition="'$(ExecutionTarget)' == 'Any'">SimulatorBackend</ResolvedQsharpExecutionTarget>
      <ResolvedQsharpExecutionTarget Condition="'$(ResolvedQsharpExecutionTarget)' != 'QuantumProcessorBackend' And '$(ResolvedQsharpExecutionTarget)' != 'SimulatorBackend'"></ResolvedQsharpExecutionTarget>
      <ValidExecutionTargets>Possible values are 'QuantumSimulator', 'ToffoliSimulator', 'TraceSimulator', or 'QuantumProcessor'.</ValidExecutionTargets>
      <CsharpGeneration Condition="'$(ResolvedQsharpExecutionTarget)' == 'SimulatorBackend'">True</CsharpGeneration>
    </PropertyGroup>
  </Target>     

  <!-- Sets all unspecified properties configuring the paths for output generated during Q# compilation. -->
  <Target Name="ResolveQscOutputPaths" AfterTargets="QsharpPropertyResolution">
    <PropertyGroup>
      <!-- path compatible assembly name -->
      <PathCompatibleAssemblyName>$([System.String]::Copy('$(AssemblyName)').Replace(' ',''))</PathCompatibleAssemblyName>
      <!-- output path for files generated during compilation -->
      <GeneratedFilesOutputPath Condition="'$(GeneratedFilesOutputPath)' == ''">$(BaseIntermediateOutputPath)qsharp</GeneratedFilesOutputPath>
      <GeneratedFilesOutputPath Condition="!HasTrailingSlash('$(GeneratedFilesOutputPath)')">$(GeneratedFilesOutputPath)\</GeneratedFilesOutputPath>    
      <!-- output path for generating documentation -->
      <QsharpDocsOutputPath Condition="'$(QsharpDocsOutputPath)' == ''">$(GeneratedFilesOutputPath)docs\</QsharpDocsOutputPath>
      <!-- output path for generated C# files -->
      <CsharpSrcOutputPath Condition="'$(CsharpSrcOutputPath)' == ''">$(GeneratedFilesOutputPath)src\</CsharpSrcOutputPath>
    </PropertyGroup>
  </Target>


  <!-- Recomputes the content of ResolvedQscReferences. The current content of these item groups is cleared during the process. -->
  <Target Name="ResolveQscReferences" DependsOnTargets="QsharpPropertyResolution;ResolveProjectReferences;ResolveAssemblyReferences;Restore">
    <!-- 
      TODO: right now, packages containing rewrite steps basically need to be self-contained. 
      _ResolveAssemblyReferenceResolvedFiles might help (the info on IsQscReference cannot be assiciated though), 
      or we will need to find a better setup in the compiler. 
    --> 

    <!-- clean the current content of the qsc item groups to recompute -->
    <ItemGroup>
      <QscProjectReference Remove="@(QscProjectReference)"/>
      <QscPackageReference Remove="@(QscPackageReference)"/>
      <ResolvedQscReferences Remove="@(ResolvedQscReferences)"/>
      <_RelevantQscProjectReference Remove="@(_RelevantQscProjectReference)"/>
      <_RelevantQscPackageReference Remove="@(_RelevantQscPackageReference)"/>
      <_RelevantQscPackageReferencePathProperty Remove="@(_RelevantQscPackageReferencePathProperty)"/>
    </ItemGroup>

    <ItemGroup>
      <QscProjectReference Include="@(_ResolvedProjectReferencePaths)" Condition="'%(_ResolvedProjectReferencePaths.IsQscReference)' == 'true'" />
      <QscPackageReference Include="@(PackageReference)" Condition="'%(PackageReference.IsQscReference)' == 'true'" />
    </ItemGroup>

    <!-- filter all project references which are qsc references; these will be executed first -->
    <ItemGroup>
      <_RelevantQscProjectReference Include="@(QscProjectReference->WithMetadataValue('ExecutionTarget',''))" /> 
      <_RelevantQscProjectReference Include="@(QscProjectReference->WithMetadataValue('ExecutionTarget','Any'))" /> 
      <_RelevantQscProjectReference Include="@(QscProjectReference->WithMetadataValue('ExecutionTarget','$(ExecutionTarget)'))" /> 
    </ItemGroup>

    <!-- filter and order all package references which are qsc references; sdk defined references will be inserted in the specified order -->
    <ItemGroup>
      <_RelevantQscPackageReference Include="@(QscPackageReference->WithMetadataValue('ExecutionTarget',''))" /> 
      <_RelevantQscPackageReference Include="@(QscPackageReference->WithMetadataValue('ExecutionTarget','Any'))" /> 
      <_RelevantQscPackageReference Include="@(QscPackageReference->WithMetadataValue('ExecutionTarget','$(ExecutionTarget)'))" /> 
    </ItemGroup>

    <ItemGroup>
      <_RelevantQscPackageReferencePathProperty Include="@(_RelevantQscPackageReference->'Pkg$([System.String]::Copy('%(_RelevantQscPackageReference.Identity)').Replace('.','_'))')" /> 
      <ResolvedQscReferences Include="@(_RelevantQscProjectReference)" /> <!-- need to be before package refs -->
      <ResolvedQscReferences Include="$(%(_RelevantQscPackageReferencePathProperty.Identity))/lib/**/*.dll" Priority="%(_RelevantQscPackageReferencePathProperty.Priority)" /> 
    </ItemGroup>

    <Message Text="Refs: (%(ResolvedQscReferences.Identity), %(ResolvedQscReferences.Priority))" Importance="High" />
    <Message Text="QuantumSdkBuildTasks: $(QuantumSdkBuildTasks)" Importance="High" />

    <PropertyGroup>
      <_QscProjectReferencesCount>@(QscProjectReference->Count())</_QscProjectReferencesCount>
      <_QscPackageReferencesCount>@(QscPackageReference->Count())</_QscPackageReferencesCount>
      <_QscReferencesCount>$([MSBuild]::Add($(_QscProjectReferencesCount), $(_QscPackageReferencesCount)))</_QscReferencesCount>
    </PropertyGroup>

  </Target>  

</Project>
