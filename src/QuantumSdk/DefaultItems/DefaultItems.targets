<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!-- Work around issues in MSBuild versions prior to 16.0. -->
  <PropertyGroup>
    <MSBuildAllProjects Condition=" '$(MSBuildVersion)' == '' Or '$(MSBuildVersion)' &lt; '16.0' ">
      $(MSBuildAllProjects);$(MSBuildThisFileFullPath)
    </MSBuildAllProjects>
  </PropertyGroup>
  
  <!-- We want access to the full path of packages as determined by msbuild to filter and reorder various package references. -->
  <ItemDefinitionGroup>
    <PackageReference GeneratePathProperty="true" IsQscReference ="false" />
  </ItemDefinitionGroup>
  

  <!-- Packages containing rewrite steps that are executed during compilation. -->
  <ItemGroup>
    <!-- for backwards compatibility we still generate C# independent on whether the project is targeted for execution on the simulation framework or not -->
    <PackageReference 
      Include="Microsoft.Quantum.CsharpGeneration" Version="0.10.1911.1607" IsImplicitlyDefined="true" 
      IsQscReference ="true" ExecutionTarget="Any" SdkInternalStage="AfterTargeting" /> <!-- Todo: we will want to make the order of execution properly configurable -->
  </ItemGroup>

  <!-- Packages and libraries included for all execution targets. -->
  <ItemGroup>
    <!-- TODO: Core & Intrinsics package -->
    <PackageReference Include="Microsoft.Quantum.Standard" Version="0.10.1911.1607" IsImplicitlyDefined="true" />
  </ItemGroup>


  <!-- Includes packages and project references depending on the defined project properties. -->
  <Target Name="PropertyDependentReferences" DependsOnTargets="QsharpPropertyResolution" BeforeTargets="ResolveAssemblyReferences">
    <ItemGroup>
      <!-- Packages included for specific execution targets. -->
      <PackageReference Condition="'$(ResolvedQsharpExecutionTarget)' == 'SimulatorBackend'" Include="Microsoft.Quantum.Simulators" Version="0.10.1911.1607" IsImplicitlyDefined="true" />
    </ItemGroup>
  </Target>   


  <!-- Resolution of verified configurable properties. -->
  <Target Name="QsharpPropertyResolution">
    <!-- resolving the OutputType to either QsharpExe or QsharpLibrary -->
    <PropertyGroup>
      <ResolvedQsharpOutputType Condition="'$(OutputType)' == 'Library'">QsharpLibrary</ResolvedQsharpOutputType>
      <ResolvedQsharpOutputType Condition="'$(OutputType)' == 'Exe'">QsharpExe</ResolvedQsharpOutputType>
      <ResolvedQsharpOutputType Condition="'$(ResolvedQsharpOutputType)' != 'QsharpLibrary' And '$(ResolvedQsharpOutputType)' != 'QsharpExe'"></ResolvedQsharpOutputType>
      <ValidOutputTypes>Possible values are 'Exe', or 'Library'.</ValidOutputTypes>
    </PropertyGroup>
    <!-- resolving the ExecutionTarget to either SimulatorBackend or QuantumProcessorBackend -->
    <PropertyGroup>
      <ResolvedQsharpExecutionTarget Condition="'$(ExecutionTarget)' == 'QuantumProcessor'">QuantumProcessorBackend</ResolvedQsharpExecutionTarget> <!-- TODO: replace that -->
      <ResolvedQsharpExecutionTarget Condition="'$(ExecutionTarget)' == 'QuantumSimulator' Or '$(ExecutionTarget)' == 'ToffoliSimulator' Or '$(ExecutionTarget)' == 'TraceSimulator'">SimulatorBackend</ResolvedQsharpExecutionTarget>
      <ResolvedQsharpExecutionTarget Condition="'$(ExecutionTarget)' == 'Any'">SimulatorBackend</ResolvedQsharpExecutionTarget>
      <ResolvedQsharpExecutionTarget Condition="'$(ResolvedQsharpExecutionTarget)' != 'QuantumProcessorBackend' And '$(ResolvedQsharpExecutionTarget)' != 'SimulatorBackend'"></ResolvedQsharpExecutionTarget>
      <ValidExecutionTargets>Possible values are 'QuantumSimulator', 'ToffoliSimulator', 'TraceSimulator', or 'QuantumProcessor'.</ValidExecutionTargets>
      <CsharpGeneration Condition="'$(ResolvedQsharpExecutionTarget)' == 'SimulatorBackend'">True</CsharpGeneration>
    </PropertyGroup>
  </Target>     

  <!-- Sets all unspecified properties configuring the paths for output generated during Q# compilation. -->
  <Target Name="ResolveQscOutputPaths" AfterTargets="QsharpPropertyResolution">
    <PropertyGroup>
      <!-- path compatible assembly name -->
      <PathCompatibleAssemblyName>$([System.String]::Copy('$(AssemblyName)').Replace(' ',''))</PathCompatibleAssemblyName>
      <!-- output path for files generated during compilation -->
      <GeneratedFilesOutputPath Condition="'$(GeneratedFilesOutputPath)' == ''">$(BaseIntermediateOutputPath)qsharp</GeneratedFilesOutputPath>
      <GeneratedFilesOutputPath Condition="!HasTrailingSlash('$(GeneratedFilesOutputPath)')">$(GeneratedFilesOutputPath)\</GeneratedFilesOutputPath>    
      <!-- output path for generating documentation -->
      <QsharpDocsOutputPath Condition="'$(QsharpDocsOutputPath)' == ''">$(GeneratedFilesOutputPath)docs\</QsharpDocsOutputPath>
      <!-- output path for generated C# files -->
      <CsharpSrcOutputPath Condition="'$(CsharpSrcOutputPath)' == ''">$(GeneratedFilesOutputPath)src\</CsharpSrcOutputPath>
    </PropertyGroup>
  </Target>


  <!-- Recomputes the content of ResolvedQscReferences. The current content of these item groups is cleared during the process. -->
  <Target Name="ResolveQscReferences" DependsOnTargets="QsharpPropertyResolution;ResolveAssemblyReferences;Restore">
    <ItemGroup>
      <!-- clean the current content of the qsc item groups to recompute, and filter all package references by which ones are qsc references -->
      <QscPackageReference Remove="@(QscPackageReference)"/>
      <RelevantQscPackageReference Remove="@(RelevantQscPackageReference)"/>
      <RelevantQscPackageReferencePathProperty Remove="@(RelevantQscPackageReferencePathProperty)"/>
      <QscPackageReference Include="@(PackageReference)" Condition="'%(PackageReference.IsQscReference)' == 'true' " />
      <ResolvedQscReferences Remove="@(ResolvedQscReferences)"/>
      <!-- project specific rewrite steps for the specified execution target -->
      <RelevantQscPackageReference Condition="'%(QscPackageReference.SdkInternalStage)' == ''" Include="@(QscPackageReference->WithMetadataValue('ExecutionTarget',''))" /> 
      <RelevantQscPackageReference Condition="'%(QscPackageReference.SdkInternalStage)' == ''" Include="@(QscPackageReference->WithMetadataValue('ExecutionTarget','Any'))" /> 
      <RelevantQscPackageReference Condition="'%(QscPackageReference.SdkInternalStage)' == ''" Include="@(QscPackageReference->WithMetadataValue('ExecutionTarget','$(ExecutionTarget)'))" /> 
      <!-- rewrite steps included in the SDK that are executed after targeting -->
      <RelevantQscPackageReference Condition="'%(QscPackageReference.SdkInternalStage)' == 'AfterTargeting'" Include="@(QscPackageReference->WithMetadataValue('ExecutionTarget',''))" /> 
      <RelevantQscPackageReference Condition="'%(QscPackageReference.SdkInternalStage)' == 'AfterTargeting'" Include="@(QscPackageReference->WithMetadataValue('ExecutionTarget','Any'))" /> 
      <RelevantQscPackageReference Condition="'%(QscPackageReference.SdkInternalStage)' == 'AfterTargeting'" Include="@(QscPackageReference->WithMetadataValue('ExecutionTarget','$(ExecutionTarget)'))" /> 
      <!-- add the included steps to the ResolvedQscReferences -->
      <RelevantQscPackageReferencePathProperty Include="@(RelevantQscPackageReference->'Pkg$([System.String]::Copy('%(RelevantQscPackageReference.Identity)').Replace('.','_'))')" /> 
      <ResolvedQscReferences Include="$(%(RelevantQscPackageReferencePathProperty.Identity))/lib/**/*.dll" /> 
      <!-- TODO: we should have a suitable setup for project references as well -->
    </ItemGroup>
  </Target>  

</Project>
